<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0054)https://reasonablypolymorphic.com/book/operations.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        <title>Operations :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
        <link href="https://reasonablypolymorphic.com/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml">
        <link href="https://reasonablypolymorphic.com/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml">

        <link href="./Operations __ Reasonably Polymorphic_files/css" rel="stylesheet" type="text/css">
        <link href="./Operations __ Reasonably Polymorphic_files/style.css" type="text/css" rel="stylesheet">
        <link href="./Operations __ Reasonably Polymorphic_files/syntax.css" type="text/css" rel="stylesheet">

        <script async="" src="./Operations __ Reasonably Polymorphic_files/analytics.js"></script><script type="text/javascript" src="./Operations __ Reasonably Polymorphic_files/jquery-2.1.4.min.js"></script>
        <script type="text/javascript" src="./Operations __ Reasonably Polymorphic_files/baseline.js"></script>
        <script type="text/x-mathjax-config;executed=true">
            MathJax.Hub.Config({
                    "HTML-CSS": {
                        scale: 50
                    },
  TeX: {extensions: [ "AMSmath.js"
                    , "AMSsymbols.js"
                    , "color.js"
                    , "http://sonoisa.github.io/xyjax_ext/xypic.js"
                    ]}
            });
        </script>
        <script src="./Operations __ Reasonably Polymorphic_files/MathJax.js" id=""></script>
          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76834556-1', 'auto');
  ga('send', 'pageview');
  </script>

        <style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
        <body><div id="MathJax_Message" style="display: none;"></div>

<div class="column">
    <article>
<header>
    <h1><a href="https://reasonablypolymorphic.com/book/operations">Operations</a></h1>
</header>
<p class="meta">
    
    <span class="prev">
        <a href="https://reasonablypolymorphic.com/book/tapes">←</a>
    </span>
    
    
    <span class="next">
        <a href="https://reasonablypolymorphic.com/book/tying-it-all-together">→</a>
    </span>
    
    <time>November 26, 2016</time>
    
        <span class="tags">
        
        </span>
    
</p>
<div class="content">
    <p>In the last chapter, we built a <code>Tape a</code> data type to support the program and memory tapes inside of the <em>P’’</em> machine we’re constructing. We made <code>Tape a</code> by using two <code>List a</code>s as the “spools” on either end of the tape, and a single <code>a</code> as the <em>read head</em> of the tape.</p>
<p>In order to achieve tapes which felt like they were infinitely long, we invented the “<code>Point</code> of interest” pattern, which offers a <code>point : Point a =&gt; a</code> value, indicating some value which is the (arbitrarily) <em>most interesting</em> value in a given type <code>a</code>. Using <code>point</code>, we were able to generate extra length on either end of the tape whenever we ran out, and as such, our tape could grow as it was necessary.</p>
<p>We then built a sum type <code>Instr</code>, which represented the possible instructions our <em>P’’</em> machine could execute. Finally, we took the product type of <code>Tape Instr</code> with a <code>Tape Nat</code> to provide program and memory tapes, and bundled them up under the type <code>P''</code>.</p>
<p>Our plan today is to write a function <code>execute : Tape Instr -&gt; Tape Nat</code>, which takes a program tape, and outputs the resulting memory tape after the <em>P’’</em> machine running the program has <em>Halt</em>ed. Our strategy to perform this execution will be identical to the example we worked through in the last chapter, although this time we’ll write a symbolic computation to do the actual work for us.</p>
<p>This “execution pipeline” will be in terms of four distinct steps:</p>
<ol style="list-style-type: decimal">
<li><em>Read</em> the instruction from the read head of the program tape.</li>
<li><em>Run</em> the instruction, modifying the state of the machine and halting if necessary.</li>
<li><em>Advance</em> the read head of the program tape if the machine hasn’t halted.</li>
<li><em>Repeat</em> the previous three steps if the machine hasn’t halted.</li>
</ol>
<p>We can represent this pipeline in terms of Kleisli functions which need to be <code>composeK</code>ed together, all running in the <code>State P''</code> Kleisli pattern.</p>
<p>The first step in this pipeline is <code>Read : State P'' Instr</code>, which simply fetches the <code>readHead</code> of the program tape hiding inside of the state of the <em>P’’</em> machine:</p>
<pre><code>read : State P'' Instr
read = do
    (P'' instrTape _) ← get
    inject (readHead instrTape)</code></pre>
<blockquote>
<p>Side Note: We use the <code>inject : Kleisli m =&gt; a -&gt; m a</code> function to take a “pure” <code>a</code> value and get it into a Kleisli context. This is important so that we have the correct output type for our function.</p>
</blockquote>
<p>Easy. The <em>Advance</em> step of the pipeline is also particularly easy, so we’ll knock it out of the way now as well:</p>
<pre><code>advance : State P'' Unit
advance = do
    (P'' progTape memTape) ← get
    set (P'' (moveRight progTape) memTape)</code></pre>
<p><code>advance</code> merely retrieves the state of the <em>P’’</em> machine, moves the program tape to the right, and updates the state of the <em>P’’</em> machine so that it reflects this. Note that this function returns <code>Unit</code>, meaning that we don’t care about it – we’re using <code>advance</code> only for the “side effects” it performs on our state.</p>
<p>We find ourselves now at the part we’ve been avoiding, the necessity of actually running the individual instructions available to our <em>P’’</em> machine. Obviously we’ll need a function to run <em>each</em> instruction, which we can then select the correct one to use via function pattern matching on our input instruction.</p>
<p>But what should the interface of these “execute an instruction” functions be? We’ll consider the kinds of things we want instructions to be able to do in order to answer this question. Upon some inspection, there are three different things our instructions can do: <em>Halt</em> the machine, manipulate the program tape, or manipulate the memory tape. The last two of those are obviously just running in the <code>State P''</code> Kleisli environment, and so all we’re left with is the <em>Halt</em>ing part.</p>
<p>At the end of the day, all we really care about from these instructions that can <em>Halt</em> is “did we actually <em>Halt</em>?” As a result, we can model our instructions as Kleisli values of the following type <code>State P'' Bool</code>. The <code>State P''</code> allows us to manipulate the state of the <em>P’’</em> machine, and the <code>Bool</code> output we’ll think of as <code>On</code> meaning “our machine is still on (we haven’t <em>Halt</em>ed)” and <code>Off</code> meaning “our machine is off (we have, in fact, <em>Halt</em>ed)”.</p>
<p>The <em>Halt</em> instruction is the simplest, so we can start there:</p>
<pre><code>instrHalt : State P'' Bool
instrHalt = inject Off</code></pre>
<p><code>instrHalt</code> is the instruction which <em>always halts</em>, and so the only thing it needs to do is to output <code>Off</code> and it’s done. Nothing to it, really.</p>
<p>The <em>Move Left</em> and <em>Move Right</em> instructions are also easy, since we already have the necessary functions to move the memory tape. Furthermore, these instructions can never <em>Halt</em>, and so there’s really no trick to them:</p>
<pre><code>instrMoveLeft : State P'' Bool
instrMoveLeft = do
    (P'' progTape memTape) ← get
    set (P'' progTape (moveLeft memTape))
    inject On</code></pre>
<pre><code>instrMoveRight : State P'' Bool
instrMoveRight = do
    (P'' progTape memTape) ← get
    set (P'' progTape (moveRight memTape))
    inject On</code></pre>
<p>Simple as borscht, really. These functions are identical to one another, except that “Left” has been replaced by “Right”. That’s good, but we find ourselves having to write a lot of “boilerplate” in order to accomplish things here. The pattern is always the same: read the state, and then replace part of the state with an updated value. Instead, we’ll write a lemma to help with this pattern:</p>
<pre><code>withMemTape : (Tape Nat -&gt; Tape Nat) -&gt; State P'' Unit
withMemTape f = do
    (P'' progTape memTape) ← get
    set (P'' progTape (f memTape))</code></pre>
<p><code>withMemTape</code> abstracts away a lot of that “get, change, set” pattern that we found ourselves writing for <code>instrMoveLeft</code> and <code>instrMoveRight</code>. <code>withMemTape</code> simply takes a function which describes how to change the memory tape, and it performs that change for you. We can thus rewrite our move instructions in terms of this new abstraction:</p>
<pre><code>instrMoveLeft : State P'' Bool
instrMoveLeft = do
    withMemTape moveLeft
    inject On</code></pre>
<pre><code>instrMoveRight : State P'' Bool
instrMoveRight = do
    withMemTape moveRight
    inject On</code></pre>
<p>To my eyes, this is much more clear in terms of what it’s accomplishing – describing “what’s going on” rather than “how to actually do it”. Notice that we could have shortened these functions a little more if we had moved the <code>inject On</code> action into the <code>withMemTape</code> lemma, but that would have had strange semantics, because it’s unclear what a <code>Bool</code> coming from <code>withMemTape</code> might mean. As such, we keep <code>withMemTape</code> outputting a <code>Unit</code>, encoding the concept that it only changes the state directly into something meaningful in its type.</p>
<p>Before getting to the <em>Increment</em> and <em>Decrement</em> instructions, we’ll need another helper lemma. It’s signature is <code>modHead: (a -&gt; a) -&gt; Tape a -&gt; Tape a</code>, which as you might expect from the name, <em>modifies the value at the read head</em> of a tape:</p>
<pre><code>modHead : (a -&gt; a) -&gt; Tape a -&gt; Tape a
modHead f (Tape ls a rs) = Tape ls (f a) rs</code></pre>
<p>With <code>modHead</code>, writing <em>Increment</em> is now simple:</p>
<pre><code>instrIncrement : State P'' Bool
instrIncrement = do
    withMemTape (modHead succ)
    inject On</code></pre>
<p>This might look a little strange if you haven’t yet quite become comfortable with the idea of function currying we looked at a few chapters ago. <code>modHead</code>’s (specialized for here, non-polymorphic) type is <code>(Nat -&gt; Nat) -&gt; Tape Nat -&gt; Tape Nat</code>, but <code>withMemTape</code> is expecting an input of type <code>Tape Nat -&gt; Tape Nat</code>. We can wrestle <code>modHead</code>’s type into the correct “shape” by giving it exactly one input – the function it should use to manipulate the read head. Here we pass <code>succ</code>, our old friend to find the successor of a <code>Nat</code>. With the <code>succ</code> input snugly in place, <code>modHead succ</code> now has the type <code>Tape Nat -&gt; Tape Nat</code>, which is exactly the right shape to be plugged into <code>withMemTape</code>.</p>
<p>We turn our attention to the <em>Decrement</em> instruction, which will cause us a little bit of grief, because it can <em>Halt</em> if the value at the read head of the memory tape is <code>Zero</code>.</p>
<pre><code>instrDecrement : State P'' Bool
instrDecrement = do
    (P'' progTape memTape) ← get
    attemptDecr (readHead memTape)
  where
    attemptDecr : Nat -&gt; State P'' Bool
    attemptDecr Zero    = inject Off
    attemptDecr (S num) = do
        withMemTape (always num)
        inject On</code></pre>
<p><code>instrDecrement</code> is written in two parts – first it pulls out the <code>readHead</code> of the memory tape, and then passes that as an input to a local lemma defined in the where-block: <code>attemptDecr</code>. This lemma pattern matches on its input; if that input is <code>Zero</code>, we simply give back <code>Off</code>, which indicates we have halted.</p>
<p>Otherwise, <code>attemptDecr</code> updates the value at the read head of the memory tape with the number <code>num</code> (which is one less than it used to be, due to the pattern matching with <code>S</code>). We use the <code>always : x -&gt; y -&gt; x</code> function to get a function which will always give back <code>num</code>, rather than depend on the current value at the read head. We can get away with doing that because we’ve already computed what it should be.</p>
<p>We’re on the home stretch! Can you feel it? All that’s left is to write the <em>Enter Loop</em> and <em>Exit Loop</em> instructions, and then wire the whole thing together. They’re a little more involved, however, so we’ll leave them until the next chapter.</p>
<hr>
<h2 id="exercises">Exercises</h2>
<ol style="list-style-type: decimal">
<li>Define an analogous <code>withProgTape : (Tape Instr -&gt; Tape Instr) -&gt; State P'' Unit</code> function.</li>
<li>Rewrite the <code>instrDecrement</code> action in terms of the <code>decr : Nat -&gt; Maybe Nat</code> function we defined when we were first looking at <code>Nat</code>s.</li>
</ol>
</div>
<p class="meta">
    
    <span class="prev">
        <a href="https://reasonablypolymorphic.com/book/tapes">←</a>
    </span>
    
    
    <span class="next">
        <a href="https://reasonablypolymorphic.com/book/tying-it-all-together">→</a>
    </span>
    
</p>
</article>

    <nav>
    <h1><a href="https://reasonablypolymorphic.com/">REASONABLY<br>POLYMORPHIC</a></h1>

    <p> Hi there. I'm <strong>Sandy Maguire</strong>. I like improving life and
    making cool things.</p>

    <p>If you want to get in touch, I'd love to hear from you! Send me an email;
    my name is <tt>sandy</tt> and this is my website.</p>

    <h2>THINGS I MAKE</h2>
    <ul>
        <li>Code on <a href="http://github.com/isovector">github</a></li>
        <li>Essays <a href="https://reasonablypolymorphic.com/blog/archives/">archive</a></li>
        <li>Book <a href="https://reasonablypolymorphic.com/book/preface">archive</a></li>
    </ul>

    <h2>WHAT I'M DOING</h2>
    <ul>
        <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
        <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
        <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li>
    </ul>

    <p>
    © 2011-2016 Sandy Maguire
    </p>
</nav>

</div>
    


</body></html>